package com.bytelegend.utils

import com.bytelegend.app.shared.CharacterAnimationInfo
import com.bytelegend.app.shared.Direction
import com.bytelegend.app.shared.Direction.*
import com.bytelegend.app.shared.PixelBlock
import com.bytelegend.app.shared.codegen.toKotlinCode
import java.io.File
import javax.imageio.ImageIO

val animationFrameWidth = 32
val animationFrameHeight = 32

fun main() {
    generateCharacterAnimationData(
        File("server/app/src/main/resources/static/img/characters"),
        File("shared/src/commonMain/kotlin/com/bytelegend/app/shared/generated/CharacterAnimations.kt")
    )
}

fun generateCharacterAnimationData(imgSrcDir: File, destKtFile: File) {
    val animations = imgSrcDir
        .listFiles { _, name -> name == "Players.png" }
        .flatMap(::convertToAnimationData)

    val ktSource = """
        package com.bytelegend.app.shared.generated
        import com.bytelegend.app.shared.CharacterAnimationInfo
        import com.bytelegend.app.shared.PixelBlock
        
        /*** NOTE: DO NOT EDIT THIS FILE MANUALLY AS IT IS AUTO GENERATED, SEE GenerateCharacterAnimationData.kt ***/
        
        val characterAnimations = listOf( 
            ${animations.toKotlinCode()}}
        )
    """.trimIndent()

    destKtFile.writeText(ktSource)
}

fun convertToAnimationData(animationImg: File): List<CharacterAnimationInfo> {
    val imgId = animationImg.name.substringBefore(".png")
    val img = ImageIO.read(animationImg)
    require(img.width % animationFrameWidth == 0) { "Invalid $animationImg: image width ${img.width}" }
    require(img.height % animationFrameHeight == 0) { "Invalid $animationImg: image height ${img.height}" }
    val ret = mutableListOf<CharacterAnimationInfo>()
    for (x in 0 until img.width / animationFrameWidth / 3) {
        for (y in 0 until img.height / animationFrameHeight / 4) {
            ret.add(
                CharacterAnimationInfo(
                    imgId,
                    "${imgId}_${x}_$y",
                    animationImg.length().toInt(),
                    getAnimationFrameBlocks(x, y, UP),
                    getAnimationFrameBlocks(x, y, DOWN),
                    getAnimationFrameBlocks(x, y, LEFT),
                    getAnimationFrameBlocks(x, y, RIGHT),
                )
            )
        }
    }
    return ret
}

fun getAnimationFrameBlocks(animationSheetX: Int, animationSheetY: Int, direction: Direction): List<PixelBlock> {
    val row = when (direction) {
        UP -> 3
        DOWN -> 0
        LEFT -> 1
        RIGHT -> 2
        else -> throw IllegalStateException("Invalid $direction")
    }
    return listOf(
        getAnimationFrameBlock(animationSheetX, animationSheetY, 0, row),
        getAnimationFrameBlock(animationSheetX, animationSheetY, 1, row),
        getAnimationFrameBlock(animationSheetX, animationSheetY, 2, row)
    )
}


/**
 * An animation sheet may contain multiple character sheet,
 * every character sheet contains 3x4 frames.
 */
fun getAnimationFrameBlock(animationSheetX: Int, animationSheetY: Int, frameX: Int, frameY: Int): PixelBlock =
    PixelBlock(
        (3 * animationSheetX + frameX) * animationFrameWidth,
        (4 * animationSheetY + frameY) * animationFrameWidth,
        animationFrameWidth,
        animationFrameHeight
    )

